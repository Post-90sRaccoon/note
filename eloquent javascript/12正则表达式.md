# 正则表达式

### creating a regular expression 

```javascript
var re1 = new RegExp("abc")
var re2 = /abc/

re1 == re2
//false 两个对象内容一样 但不是同一个对象

//空白正则表达式
let a = new RegExp('')
//    / (?:) /

var a = new RegExp('\\a')
//  /\a/ 会转义
a2 = /\\a/
// /\\a/
a3 = new RegExp(String.fromCharCode(92, 97))
// /\a/

// / a/bc /    用/a\/bc/来表示
a4 = new RegExp(String.fromCharCode(97, 92, 47, 98, 99))
a5 = new RegExp('a\\/bc')
a = new RegExp('a/bc')


\s 就是s
\k 就是k  被忽略掉

/a+/
//连续出现字母a多于一次

/a\+/ 
//表示一个a和加号

/a\+/.test('wioefa+joisf')
//true
```

> 不确定标点符号是否需要转义 可以都加上\

#### 正则表达式的test方法（返回boolean）

```javascript
console.log(/abc/.test('abcde'))
'abcde'.indexOf('abc')
```

#### 匹配一组字符

```javascript
console.log(/[az035]/.test('abcde'))
// []匹配单个字符  里面任意一个

\d 相当于[0-9]   dight
\w [0-9a-zA-Z\_] word character
\s space,tab,newline,and similar 全角空格也算
\D 不是数字
\W 不是word character
\S 非空格 

. 除newline外任意符号 ''空字符不行 必须有一个字符 \r\n \r \n 都不可以
```

```javascript
console.log(/\d\d-\d\d-\d\d\d\d \d\d:\d\d/.test('30-01-2003 15:20'))

[\d.] 代表一个数字或者.  .在方括号里失去了特殊意义 
 
 /[^2357]/
// caret 脱字符 反选 非2357外的任意 数字
 / [se ^ 2] /
//不出现在开头 不代表反选 匹配四个字符中的任意一个

let notBinary = /[^01]/
```

#### 重复匹配

```javascript

```

### 动态规划

#### 最长回文串

> 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

```javascript
// 用数组统计 A-z出现的次数 count
// 回文串长度 += count >> 1 * 2 
// 如果任何一个count 是奇数 count可以再+1  length > sum 说明有奇数
var longestPalindrome = function(s) {
    let sum = 0
    let ary = new Array(58).fill(0) //122-65+1
    let length = s.length
    for(let i =0;i<length;i++){
        ary[s[i].charCodeAt()-65]++
    }
    for(let i =0;i<58;i++){
        let count = ary[i]
        if(count){
            sum += (count>>1)*2
        }
    }
    sum = length>sum ? ++sum : sum
    return sum
};
```

#### 最长回文子序列

> 可以不连续 但不能破坏相对位置
>
> 递归的考虑问题 如果字符串两侧字符相同 那么等于中间的最长回文子序列+2
>
> 如果不等 等于去头的最长回文子序列 和 去尾中间的最长回文子序列 的 最大值

```javascript
//递归
function f(s) {
  if (s.length <= 1) {
    return s
  } else {
    if (s[0] == s[s.length - 1]) {
      return s[0] + f(s.slice(1, -1)) + s[0]
    } else {
      let a = f(s.slice(0, -1))
      let b = f(s.slice(1))
      return a.length > b.length ? a : b
    }
  }
}
```

```javascript
//动态规划
//状态 f[i][j] 表示第i到第j个字符组成的字符串中，最长的回文序列是多少 i>=j
//转移方程 s[i]==s[j]  f[i][j] = f[i+1][j-1] + 2
//        s[i]!==s[j] f[i][j] = max(f[i+1][j],f[i][j-1])
// 分析 f[i][j] 与f[i+1][j-1] f[i+1][j] f[i][j-1]有关
// 所以先求f[i+1][...] f[i][i]
// 遍历顺序 i从最后 j从i+1往后遍历 保证每个子问题遍历好
// 初始化 f[i][i] = 1
// 结果 f[0][n-1]


function longestPalindromeSubseq(s){
  let n = s.length
  let f = new Array(n)
  for(let i =0;i<n;i++){
    f[i] = new Array(n).fill(0)   //fill(0)目的是将非法空间 i>j 填0
  }
  for(let i = n-1;i>=0;i--){
    f[i][i] = 1
    for(let j = i+1;j<n;j++){
      if (s.charAt(i) == s.charAt(j)){
        f[i][j] = f[i+1][j-1] + 2
      }else{
        f[i][j] = Math.max(f[i+1][j],f[i][j-1])
      }
    }
  }
  return f[0][n-1]
}
```

#### 最长回文子串

> substring(start,end) 不包含end
>
> substr(start,length) 从start开始 长度为length的字符串

```javascript
//对于一个子串 如果是回文串 且长度大于二 去除首尾两字母 仍是回文串
// s[i:j] 表示s的第i到第j个字母组成的串
// P(i,j)表示s[i:j]的第i到j个字母组成的串是否为回文串
// s[i:j]不是回文串 或者i>j s[i:j]不合法 是为false
// 状态转移方程 P(i,j) = P(i+1,j-1) & (Si == Sj)
// 只和更短的有关
// 边界条件 长度小于2 P(i,i) = true P(i,i+1) = (Si == Si+1)


function longestPalindrome(s) {
  let n = s.length
  let p = new Array(n)
  for (let i = 0; i < n; ++i) {
    p[i] = new Array(n)
  }
  let result = ""
  for (let l = 0; l < n; ++l) {
    for (let i = 0; i + l < n; ++i) {
      let j = i + l
      if (l == 0) {
        p[i][j] = true
      } else if (l == 1) {
        p[i][j] = (s[i] == s[j])
      } else {
        p[i][j] = (s[i] == s[j]) && p[i + 1][j - 1]
      }
      if (p[i][j] && l + 1 > result.length) {
        result = s.substring(i,j+1)
      }
    }
  }
  return result
}
```

![image-20201124221456017](12%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20201124221456017.png)

```javascript
function longestPalindrome(s) {
  if (s == null || s.length < 1) {
    return ""
  }
  let start = 0, end = 0
  for (let i = 0; i < s.length; i++) {
    let len1 = expandAroundCenter(s, i, i)
    let len2 = expandAroundCenter(s, i, i + 1)
    let len = Math.max(len1, len2)
    if (len > (end - start + 1)) {
      start = i - ((len - 1) >> 1)
      end = i + (len >> 1)
    }
  }
  return s.substring(start, end + 1)
}


function expandAroundCenter(s, left, right) {
  while (left >= 0 && right < s.length && s[left] == s[right]) {
    --left
    ++right
  }
  return right - left - 1
  //   // 因为--left ++right 跳到这里时s[left]!=s[right]
  //   // 比本来多了2 本来是right-left+1  减去2
}
```

##### 方法三 manacher 算法

> https://zhuanlan.zhihu.com/p/70532099

#### 零钱兑换

> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

```javascript
//  dp[i] 表示  数额为i的最小硬币数
//  dp[0] = 0
//  if(i>amount[j]) dp[i] = Math.min(1+ dp[i-coins[j]])
var coinChange = function (coins, amount) {
  let n = amount + 1
  let dp = new Array(n).fill(n)
  dp[0] = 0
  for (let i = 1; i < n; i++) {
    for (let j = 0; j < coins.length; j++) {
      if (i >= coins[j]) {
        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1)
      }
    }
  }
  return dp[amount] > amount ? -1 : dp[amount]
};
```

