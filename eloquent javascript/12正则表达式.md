# 正则表达式

> 网站 https://regex101.com/
>
> regexper.com

### creating a regular expression 

```javascript
var re1 = new RegExp("abc")
var re2 = /abc/

re1 == re2
//false 两个对象内容一样 但不是同一个对象

//空白正则表达式
let a = new RegExp('')
//    / (?:) /

var a = new RegExp('\\a')
//  /\a/ 会转义
a2 = /\\a/
// /\\a/
a3 = new RegExp(String.fromCharCode(92, 97))
// /\a/

// / a/bc /    用/a\/bc/来表示
a4 = new RegExp(String.fromCharCode(97, 92, 47, 98, 99))
a5 = new RegExp('a\\/bc')
a = new RegExp('a/bc')


\s 就是s
\k 就是k  被忽略掉

/a+/
//连续出现字母a多于一次

/a\+/ 
//表示一个a和加号

/a\+/.test('wioefa+joisf')
//true
```

> 不确定标点符号是否需要转义 可以都加上\

#### 正则表达式的test方法（返回boolean）

```javascript
console.log(/abc/.test('abcde'))
'abcde'.indexOf('abc')
```

#### 匹配一组字符

```javascript
console.log(/[az035]/.test('abcde'))
// []匹配单个字符  里面任意一个

\d 相当于[0-9]   dight
\w [0-9a-zA-Z\_] word character
\s space,tab,newline,and similar 全角空格也算
\D 不是数字
\W 不是word character
\S 非空格 

. 除newline外任意符号 ''空字符不行 必须有一个字符 \r\n \r \n 都不可以
```

```javascript
console.log(/\d\d-\d\d-\d\d\d\d \d\d:\d\d/.test('30-01-2003 15:20'))

[\d.] 代表一个数字或者.  .在方括号里失去了特殊意义 
 
 /[^2357]/
// caret 脱字符 反选 非2357外的任意 数字
 / [se^2] /
//不出现在开头 不代表反选 匹配四个字符中的任意一个

let notBinary = /[^01]/
```

#### 重复匹配

```javascript
\d+  一次或多次
\d*  0次,1次或多次
\d?  0次或一次
\d{4} 出现四次 需要连续 不需要相同
\d{2,4} 出现两到四次
\d{5,} 至少出现5次
\d{0,8} 
{,8} 没有这种写法 这种写法匹配他自己'{,8}'
console.log(/\d{2}-\d{2}-\d{4} \d{2}:\d{2}/.test('30-01-2003 15:20'))
```

#### 分组

> 当括号后面有操作符时，括号内的内容是会被算成一体的。 

#### 匹配和分组

> exec 方法 找不到返回null 找到返回

```javascript
/f\doo/.exec('kf3oows')
//["f3oo", index: 1, input: "kf3oows", groups: undefined]
```

#### 分组捕获

```javascript
/(\d{4})-(\d{2})-(\d{2})/.exec('today is 2020-04-11 sunny')
//["2020-04-11", "2020", "04", "11", index: 9, input: "today is 2020-04-11 sunny", groups: undefined]
```

```javascript
/(\d){4}-(\d{2})-(\d{2})/.exec('today is 2020-04-11 sunny')
//["2020-04-11", "0", "04", "11", index: 9, input: "today is 2020-04-11 sunny", groups: undefined]
//(\d){4} 第一次匹配2 第二次0 第三次2 第四次0
```

```javascript
console.log(/(fo\d)/.exec('fo1fo2'))
// [ 'fo1', 'fo1', index: 0, input: 'fo1fo2', groups: undefined ]
console.log(/(fo\d)+/.exec('fo1fo2'))
// [ 'fo1fo2', 'fo2', index: 1, input: 'afo1fo2', groups: undefined ]
console.log(/foo(bar(baz)+)+/.exec('xxxxfoobarbazbazbazbarbazbazxxxx'))
// [
//   'foobarbazbazbazbarbazbaz',
//   'barbazbaz',
//   'baz',
//   index: 4,
//   input: 'xxxxfoobarbazbazbazbarbazbazxxxx',
//   groups: undefined
// ]

console.log(/(\d\d)(\d\d)(\d\d)(\d{4})(\d\d)(\d\d)(\d{3})(\d)/.exec('370204200312215987'))
```

```javascript
let quotedText = /'[^']*'/
console.log(quotedText.exec("she said 'hello'"))
// [ "'hello'", index: 9, input: "she said 'hello'", groups: undefined ]

console.log(/fo(oo)? (ba+)/.exec('fo baaaaa'))
// [
//   'fo baaaaa',
//   undefined,
//   'baaaaa',
//   index: 0,
//   input: 'fo baaaaa',
//   groups: undefined
// ]

console.log(/(?<year>\d{4})-(?<mouth>\d\d)-(?<day>\d\d)/.exec('wfel 2020-04-15'))
// [
//   '2020-04-15',
//   '2020',
//   '04',
//   '15',
//   index: 5,
//   input: 'wfel 2020-04-15',
//   groups: [Object: null prototype] { year: '2020', mouth: '04', day: '15' }
// ]

/(?<firstName>.)(?<lastName>.+)/.exec('周树人')
```

#### Date类型对象介绍

```javascript
let timestamp = 10086 //1970-01-01 00:00:00.000
console.log(new Date())
// 返回的是对象 不是字符串 要字符串可以.toSring()
//2020-11-27T14:04:48.095Z
//Fri Nov 27 2020 22: 06: 57 GMT + 0800(中国标准时间) 浏览器
console.log(new Date('2020-04-15 14:30'))
//2020-04-15T06:30:00.000Z
//Wed Apr 15 2020 14:30:00 GMT+0800 (中国标准时间) 浏览器
```

```javascript
console.dir()
//看对象所有属性
```

> new Date()  
>
> 可以不写 相当于0
>
> 写字符串 ('2009-02-01') 2009年2月1日
>
> 写数(2009,2,1)这样是3月1日 只有月从0开始
>
> 写(864000)距离1970年多少毫秒、

```javascript
new Date.getTime()
// 距离1970年多少毫秒
Date.now()
// 不需要构建对象,直接返回现在距1970年多少秒
```

> Date对象有如下方法
>
> getFullYear()
>
> getMonth()
>
> getDate()
>
> getHours()
>
> getMinutes()
>
> getSeconds()



> toStirng()
>
> getTimezoneOffset()  时区偏移量
>
> toISOString()	2020-11-27T14:55:50.815Z  标椎ISO时间日期格式
>
> toGMTString()  Fri, 27 Nov 2020 14:58:15 GMT
>
> toUTCString() Fri, 27 Nov 2020 14:59:17 GMT 
>
> toTimeString()  22:57:06 GMT+0800 (中国标准时间)
>
> toDateString() Fri Nov 27 2020
>
> toLocaleString() 2020/11/27 下午11:02:18

```javascript
function findDate(string) {
  let dateTime = /(\d{1,2})-(\d{1,2})-(\d{4})/
  let match = dateTime.exec(string)
  console.log(Number(match[1]))
  return new Date(Number(match[3]), Number(match[2]) - 1, Number(match[1]))
}
console.log(findDate('30-1-2003'))
//Thu Jan 30 2003 00:00:00 GMT+0800 (中国标准时间) 浏览器
//2003-01-29T16:00:00.000Z node
```

#### Moment.js 库

```html
<script src="https://momentjs.com/downloads/moment.min.js"></script>
<script>
    let timeString = moment('2020-04-15 15:33').format('YY/MM/DD hh:mm:ss')
  </script>
```

> moment("20111031","YYYYMMDD").fromNow()    9 years ago
>
> moment().startOf('day').fromNow()	a day ago
>
> moment().endOf('day').fromNow()	in 44 minutes
>
> moment().endOf('hour').fromNow()	in 44 minutes

> moment().subtract(10,'days').calendar() "11/17/2020"
>
> moment().subtract(3,'days').calendar()  "Last Tuesday at 11:18 PM"
>
> moment().subtract(1,'days').calendar()  "Yesterday at 11:18 PM"
>
> moment().add

> monment.locale()
>
> moment.format()
>
> navigator对象里有语言

* i18n 国际化  18个字母
* l10n 本地化

#### Word and string boundaries 匹配单词及字符串的边界

```javascript
console.log(/^foo/.test('owfdkfoo'))
// ^ 零宽字符 零宽断言 字符串开始位置
console.log(/foo$/.test('owfdkfoo'))
// $ 字符串结束位置

 /^\d+$/
//匹配完全由数字组成的字符串
  
// \b 单词边界
console.log(/\bfoo\b/.test('foo a'))
//true
console.log(/\bfoo\b/.test('fooa'))
// false
console.log(/\bfoo\b/.test('(foo)a'))
//true

//'(rrr.)'
//这里不是(这里是单词边界rrr这里是单词边界.这里不是)这里不是
```

> 如果一个位置一边是字符 另一边不是 那么这个位置就是单词边界  字符指的是\w  字母数字和_

```javascript
console.log(/(?=bar)/.exec('sbarfdk'))
// (?=bar) 整体是一个零宽断言 匹配右边是bar的位置 正预测先行断言
// [ '', index: 1, input: 'sbarfdk', groups: undefined ]
// 0s1b2a3r4f5d6k7
console.log(/foo(?=bar)/.exec('abcdfoobarefg'))
// [ 'foo', index: 4, input: 'abcdfoobarefg', groups: undefined ]

/fo.(?!bar)/
//右面不是bar的位置 负预测先行断言
/?<=xxx/
//匹配左边是xxx的位置
/?<!xxx/
//匹配左边不是xxx的位置
```

```javascript
/(?!.*foo)/
// foo前出现任意都不行

/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$/
// 开始位置右面有数字 小写字母 大写字母  8-10个字符
```

```javascript
//^ 
(?<!.)
//$ 
(?!.)
//\b
(?=\w)(?< !\w) | (?<=\w) (? !\w)
(?=\w) (?<=\W)| (?<=\w) (?=\w)| (? !.) | (?< !.)
```

#### 选择性匹配

> |  或 

```javascript
console.log(/\b\d+ (pig|cow)s?\b/.exec('15 cows'))
//[ '15 cows', 'cow', index: 0, input: '15 cows', groups: undefined ]
// ?: 非捕获分组
console.log(/\b\d+ (?:pig|cow)s?\b/.exec('15 cows'))
//[ '15 cows', index: 0, input: '15 cows', groups: undefined ]

console.log(/\b\d+ (?:pig|cow)(s?)\b/.exec('15 cow'))
//[ '15 cow', '', index: 0, input: '15 cow', groups: undefined ]
console.log(/\b\d+ (?:pig|cow)(s)?\b/.exec('15 cow'))
//[ '15 cow', undefined, index: 0, input: '15 cow', groups: undefined ] 
```

#### 正则表达式的匹配机制

> 类似走迷宫  记录分支点 走不通就回退 换一条路走

```javascript
let a = /^[+-]?(0|[1-9]\d*)(\.\d+)?(e[+-]?\d+)?$/i.test('1.3e-3')
console.log(a)
```

#### Backtracking 回溯 

```javascript
/\b([01]+b|\d+|[\da-f]+h)\b/
// 匹配2进制 十进制 16进制

/^.*x/.test('abcxe')
//.*先尝试匹配最多的数 发现后面没有x 所以尝试后面少匹配一个符号

/([\d+]+d)/
   
回溯过多
正则DOS Deny Of Server
```

### 动态规划

#### 最长回文串

> 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

```javascript
// 用数组统计 A-z出现的次数 count
// 回文串长度 += count >> 1 * 2 
// 如果任何一个count 是奇数 count可以再+1  length > sum 说明有奇数
var longestPalindrome = function(s) {
    let sum = 0
    let ary = new Array(58).fill(0) //122-65+1
    let length = s.length
    for(let i =0;i<length;i++){
        ary[s[i].charCodeAt()-65]++
    }
    for(let i =0;i<58;i++){
        let count = ary[i]
        if(count){
            sum += (count>>1)*2
        }
    }
    sum = length>sum ? ++sum : sum
    return sum
};
```

#### 最长回文子序列

> 可以不连续 但不能破坏相对位置
>
> 递归的考虑问题 如果字符串两侧字符相同 那么等于中间的最长回文子序列+2
>
> 如果不等 等于去头的最长回文子序列 和 去尾中间的最长回文子序列 的 最大值

```javascript
//递归
function f(s) {
  if (s.length <= 1) {
    return s
  } else {
    if (s[0] == s[s.length - 1]) {
      return s[0] + f(s.slice(1, -1)) + s[0]
    } else {
      let a = f(s.slice(0, -1))
      let b = f(s.slice(1))
      return a.length > b.length ? a : b
    }
  }
}
```

```javascript
//动态规划
//状态 f[i][j] 表示第i到第j个字符组成的字符串中，最长的回文序列是多少 i>=j
//转移方程 s[i]==s[j]  f[i][j] = f[i+1][j-1] + 2
//        s[i]!==s[j] f[i][j] = max(f[i+1][j],f[i][j-1])
// 分析 f[i][j] 与f[i+1][j-1] f[i+1][j] f[i][j-1]有关
// 所以先求f[i+1][...] f[i][i]
// 遍历顺序 i从最后 j从i+1往后遍历 保证每个子问题遍历好
// 初始化 f[i][i] = 1
// 结果 f[0][n-1]


function longestPalindromeSubseq(s){
  let n = s.length
  let f = new Array(n)
  for(let i =0;i<n;i++){
    f[i] = new Array(n).fill(0)   //fill(0)目的是将非法空间 i>j 填0
  }
  for(let i = n-1;i>=0;i--){
    f[i][i] = 1
    for(let j = i+1;j<n;j++){
      if (s.charAt(i) == s.charAt(j)){
        f[i][j] = f[i+1][j-1] + 2
      }else{
        f[i][j] = Math.max(f[i+1][j],f[i][j-1])
      }
    }
  }
  return f[0][n-1]
}
```

#### 最长回文子串

> substring(start,end) 不包含end
>
> substr(start,length) 从start开始 长度为length的字符串

```javascript
//对于一个子串 如果是回文串 且长度大于二 去除首尾两字母 仍是回文串
// s[i:j] 表示s的第i到第j个字母组成的串
// P(i,j)表示s[i:j]的第i到j个字母组成的串是否为回文串
// s[i:j]不是回文串 或者i>j s[i:j]不合法 是为false
// 状态转移方程 P(i,j) = P(i+1,j-1) & (Si == Sj)
// 只和更短的有关
// 边界条件 长度小于2 P(i,i) = true P(i,i+1) = (Si == Si+1)


function longestPalindrome(s) {
  let n = s.length
  let p = new Array(n)
  for (let i = 0; i < n; ++i) {
    p[i] = new Array(n)
  }
  let result = ""
  for (let l = 0; l < n; ++l) {
    for (let i = 0; i + l < n; ++i) {
      let j = i + l
      if (l == 0) {
        p[i][j] = true
      } else if (l == 1) {
        p[i][j] = (s[i] == s[j])
      } else {
        p[i][j] = (s[i] == s[j]) && p[i + 1][j - 1]
      }
      if (p[i][j] && l + 1 > result.length) {
        result = s.substring(i,j+1)
      }
    }
  }
  return result
}
```

![image-20201124221456017](12%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.assets/image-20201124221456017.png)

```javascript
function longestPalindrome(s) {
  if (s == null || s.length < 1) {
    return ""
  }
  let start = 0, end = 0
  for (let i = 0; i < s.length; i++) {
    let len1 = expandAroundCenter(s, i, i)
    let len2 = expandAroundCenter(s, i, i + 1)
    let len = Math.max(len1, len2)
    if (len > (end - start + 1)) {
      start = i - ((len - 1) >> 1)
      end = i + (len >> 1)
    }
  }
  return s.substring(start, end + 1)
}


function expandAroundCenter(s, left, right) {
  while (left >= 0 && right < s.length && s[left] == s[right]) {
    --left
    ++right
  }
  return right - left - 1
  //   // 因为--left ++right 跳到这里时s[left]!=s[right]
  //   // 比本来多了2 本来是right-left+1  减去2
}
```

##### 方法三 manacher 算法

> https://zhuanlan.zhihu.com/p/70532099

#### 零钱兑换

> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

```javascript
//  dp[i] 表示  数额为i的最小硬币数
//  dp[0] = 0
//  if(i>amount[j]) dp[i] = Math.min(1+ dp[i-coins[j]])
var coinChange = function (coins, amount) {
  let n = amount + 1
  let dp = new Array(n).fill(n)
  dp[0] = 0
  for (let i = 1; i < n; i++) {
    for (let j = 0; j < coins.length; j++) {
      if (i >= coins[j]) {
        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1)
      }
    }
  }
  return dp[amount] > amount ? -1 : dp[amount]
};
```

