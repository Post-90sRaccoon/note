#### 数组

* ary = [] 创建一个空数组 

* ary = Array(5) 创建一个有5个下标/位置的数组

* ary = [1,2,3] 创建初始化的数组

* ary.length 可以查看数组中元素的个数

* ary.length 可以随时被赋值 大empty 小删除

* ary.push() 向数组末尾添加元素并返回添加后新数组的长度

* ary.pop() 返回数组的最后一项并将其从数组中删除

* ary.unshift() 向数组的头部添加元素并返回添加后数组新的长度

* ary.shift() 返回数组的第一项并将其从数组中删除

  ##### indexof

  ```javascript
  console.log([1, 2, 3, 2, 1].indexOf(2))
  //1  从头开始找2 下标为1
  console.log([1, 2, 3, 2, 1].lastIndexOf(2))
  //3  从后开始找2 下标为3
  console.log([1, 2, 3, 2, 1].indexOf(2, 2))
  //3  第二个参数是从第几个（也是数组下标）开始找 也是下标
  ```

  ```javascript
  function indexOf(ary, value, start) {
    if (start == undefined) {
      start = 0
    }
    for (var i = start; i < ary.length; ++i) {
      if (ary[i] == value) return i
    }
    return -1
  }
  
  function lastIndexOf(ary, value, start) {
    if (start == undefined) {
      start = 0
    }
    for (var i = start; i >= 0; --i) {
      if (ary[i] == value) return i
    }
    return -1
  }
  ```

  ##### slice

  ```javascript
  console.log([0, 1, 2, 3, 4].slice(2, 4))
  //[2, 3]        接收两个下标 包含开始下标不包含结束下标
  console.log([0, 1, 2, 3, 4].slice(2))
  //[ 2, 3, 4 ]   
  
  [1,2,3].slice() 
  //返回另一个数组 不改变原数组
  t = nums.slice() 
  ```
  ![image-20200114174113828](003%E6%95%B0%E7%BB%84.assets/image-20200114174113828.png)

  ```javascript
  a = [0, 0]
  b = a.slice()
  console.log(a)
  //[ 0, 0 ]
  console.log(b)
  //[ 0, 0 ]
  a[0] = 8
  console.log(a)
  //[ 8, 0 ]
  console.log(b)
  //[ 0, 0 ]
  
  
  // 如果数组里的是对象
  a = [{}, {}]
  b = a.slice()
  console.log(a)
  //[{}, {}]
  console.log(b)
  //[{}, {}]
  a[0].foo = 8
  console.log(a)
  //[{ foo: 8 }, {}]
  console.log(b)
  //[{ foo: 8 }, {}]
  ```

  

  ```javascript
  function slice(ary, start, end) {
    var result = []
    if (end == undefined) {
      end = ary.length
    }
    if (start== undefined) {
      start = 0
    }
    for (var i = start; i < end; ++i) {
      result.push(ary[i])
    }
    return result
  }
  ```

  ```javascript
  function push(ary, val) {
    ary[ary.length] = val
    return ary.length
  }
  // return 的 ary.length 自动增加
  ```

  > slice concat 出来的数组 浅拷贝 (shallow copy)
  >
  > 深拷贝把里面的对象也复制一份
  >
  > a == b 浅对比
  >
  > isEqual是深对比 (deep copy) 对比内容 即使不是同一个对象也可以
  >
  > 浅对比对比的是对象所在内存位置是不是一样
  
  ##### concat
  
  ```javascript
  //拼接数组 
  function remove(array,index) {
    return array.slice(0,index).concat(array.slice(index+1))
  }
  ```
  
  ```javascript
  function concat(ary1, ary2) {
    result = []
    for (var i = 0; i < ary1.length; ++i) {
      result.push(ary1[i])
    }
    for (var i = 0; i < ary2.length; ++i) {
      result.push(ary2[i])
    }
    return result
  }
  ```
  
  ```javascript
  var a = []
  console.log(a.concat([4, 5], 'a', 'a', [9, 8]))
  //[ 4, 5, 'a', 'a', 9, 8 ]
  console.log(a.concat([[4], [5]], 'a', 'a', [[9, 8]]))
  //[ [ 4 ], [ 5 ], 'a', 'a', [ 9, 8 ] ] 
  ```
  
  ##### copyWithin()
  
  * 浅复制数组的一部分到同一数组的另一个位置，并返回它，不会改变原数组长度
  * 支持倒着数，最右面-1，然后-2
  
  ```javascript
  const array1 = ['a', 'b', 'c', 'd', 'e']
  
  //把下标3到4不包含4的拷贝到下标一
  console.log(array1.copyWithin(0, 3, 4))
  //['d', 'b', 'c', 'd', 'e']
  
  //把下标从3开始到最后的拷贝到下标一位置
  console.log(array1.copyWithin(1, 3))
  //['d', 'd', 'e', 'd', 'e']
  
  console.log(array1.copyWithin(0, 4, 5))
  //[ 'e', 'd', 'e', 'd', 'e' ]
  ```
  
  ##### fill()
  
  ```javascript
  a.fill(0)
  //把数组a全填充成0
  Array(10).fill(0)
  
  function fill(ary, val, start, end) {
    for (i = start; i < end; ++i) {
      ary[i] = val
    }
  }
  ```
  
  ```javascript
  function join(ary, joiner) {
    var result = ''
   for(var i = 0; i < ary.length - 1; i++) {
     //最后一项不拼
      result = result + ary[i] + joiner
   }
   return result
  }
  ```
  
  ##### reverse()
  
  * 把原数组反转
  
  ##### splice()
  
  ```javascript
  //修改原数组 返回被删掉的元素
  a = [1, 2, 3, 4, 5, 6]
  a.splice(2, 3, 'a', 'b', 'c', 'd')
  // 从下标2开始 删除三个元素 替换为后面的
  console.log(a)
  // [
  //   1, 2, 'a', 'b',
  //   'c', 'd', 6
  // ]
  
  console.log(a.splice(2))
  //[ 'a', 'b', 'c', 'd', 6 ]
  //把下标2之后的全删了
  
  ```
  
   ##### toString
  
  * 以逗号拼接，相当于join不写参数
  
    ```javascript
     Array.form([1,2,3])
     // 把类数组转换成数组
    Array.isArray()
    //判断一个数组是不是真数组
    Array.of(3,4,5,6) 
    //由3,4,5,6组成的数组
    Array(8,9,10,11)
    //创建一个由8，9,10,11组成的数组
    ```
  
  ###字符串
  
  * 布尔，数字，字符串原始数据类型不是对象 ，增加属性也没有用。null和undefined增加属性会报错。
  
  * 原始数据类型不是对象，能读出属性是因为被转成了Object(2).toFixed()
  
    ![image-20200114203321096](003%E6%95%B0%E7%BB%84.assets/image-20200114203321096.png)
  
    原始对象  包装对象
  
    ![image-20200114203554783](003%E6%95%B0%E7%BB%84.assets/image-20200114203554783.png)
  
    * 包装对象类型是Object  
  
      ```javascript
      new String('wje')
      //等价于
      Object('wje')
      ```
  
  * 字符串也有slice和index方法。但是与数组的slice不同，字符串的indexOf可以接受多个字符
  
    `console.log('one two three'.indexOf("ee"))`
  
  * trim方法，删掉字符串的所有空白和回车
  
  * charAt方法
  
  * length属性 
  
    ```javascript
    console.log(String.fromCharCode(25105, 97))
    //我a   给出ascii码 返回字符
    
    var a = 'abc'
    console.log(a.charCodeAt(0))
    // 97
    
    console.log(a.concat('fasji', 'fajsdj'))
    //abcfasjifajsdj
    //拼接 返回新的 原生string不可变
    
    a.endsWith('c')
    a.startsWith('a')
    a.includes()
    //查找是否包含某个字符
    
    localeCompare
    
    '25'.padStart(8, ' ')
    //填充符号至8位 默认就是空格
    '25'.padEnd(8)
    
    '25'.repeat(10)
    //把字符串重复十次
    
    'ofoasdf'.substr(2, 4)
    //从下标2开始，截四个出来
    'ofoasdf'.substring(2, 4)
    //从下标2到下标4 不包括4
    
    
    'fdasdf,fdas,fyt,tr'.split(',')
    //字符串按照，分割 返回一个数组
    ```
  
    #### Math Object
  
    > 全局变量名 
    >
    > name 会返回字符串
    >
    > status
    >
    > top
    >
    > 不要使用 所以尽量使用let 命名 同名变量不能命名两次 
    >
    > 
    >
    > 常量全大写
    >
    > Math.random() 
    >
    > 随机数函数 0-1 伪随机数 平方取中法 线性同余算法生成随机数 
    
    #### 回顾
    
    ```javascript
    a = Array(6)
    a.push(1)
    console.log(a[6], a.length)
    //Output: 1 7  不会push到第一个
    ```
    
    ```javascript
    a = Array(6).fill([])
    console.log(a)
    a[0].push(1, 2, 3)
    console.log(a)
    
    // [[], [], [], [], [], []]
    // [
    //   [1, 2, 3],
    //   [1, 2, 3],
    //   [1, 2, 3],
    //   [1, 2, 3],
    //   [1, 2, 3],
    //   [1, 2, 3]
    // ]
    //fill的是同一个数组 改变一个 其他所有都会变
    ```
    
    ```javascript
    function fill(ary, valueCreater) {
      for (var i = 0; i < ary.length; i++) {
        ary[i] = valueCreater()
      }
      return ary
    }
    
    fill(Array(6), function () { return [] })
    //fill不同数组 
    ```
    
    
    
    
#### 浮点数在计算机内部的存储形式

* 64bit  8Byte
* 1符号位 11指数位  52科学计数法的小数部分
* 指数部分用0表示-1023 所以指数部分要加上1023  表示范围-1023 - 1024 （移码）



* 为什么指数部分不用补码 方便比较浮点数大小  谁先出现1谁大  浮点数更多时候对比大小而非对比相等，浮点数不精确 。a*b/c的结果和a/c\*b的结果有可能不同。而是比较其差的绝对值是否小于某个精度。

* 有效数位53位 数值越大 整数部分需要的有效数位越多 小数部分有效位数越少 

* 数值越大小数部分精度越小

* Number.MAX_SAFE_INTEGER  2^53^-1 

* 可以保证2^53^范围内整数运算的精确

* Number.EPSILON 大于0的第一个数

* IEEEE754 

  